1. запихнуть все данные в БД (проще использовать SQLite)
  - на кадый месяц - 4 вида графика (рабочий до и после, камасктра до и после)
  - расчеты сумм ведутся по каждому графику (надо считать отраб часы, все часы, ночные, и еще 
    что посмотреть)
  - на основе одного вида графика можно создать другой, если его еще нет

2. Документ для каждого экспорта хранится в настройках программы, при экспрте открывается 
  автоматически. Если нужно экспортировать в другой, то только в этом случае задавать его руками 


3 . Таблицы 
  GRAPH_TYPES - типы графиков +++
    tid - integer
    tname - varchar
    torder - integer - порядок типа графика, если 0, то не используется

  WORKERS - работники +++
    wid - integer
    wname - varchar

  SORT_INFO - информация о сортировках графика +++
    sid - integer
    sname - varchar 
  
  SORT_ORDER - порядок сортировки  (благодоря этой таблице проще будет получать данные графика) +++
    oid - ид строки
    sid - integer - ид порядка сортировки
    oindex - integer - порядок работника, 
    wid - integer - ид работника

  GRAPH_INFO - инфа о месячном графике (она одна для всех графиков всех типов на указанный месяц)
    gid - integer - ид графика
    gyear - integer - год
    gmonth - integer - месяц
    sid - integer - порядок сортировки (и кто из людей находится в этом графике) 
    wlist - integer - список выходных. по факту это 32 бит uint, в котором каждый бит=1, 
            если это выходной или праздник
    udata - varchar(2000) - комментраии к графику

  GRAPH_DATA - данные работников (строки о работниках на каждый месяц)
    id  - integer - ид записи 
    gid - integer - какой график
    tid - integer - тип графика
    wid - integer - ид человека
    gdata - varchar  - строка с данными человека (та же строка, что и в файловой версии).

  S_DATA - данные суммированного учета (EAV получается)
    aid - integer - id записи
    wid - integer - id работника
    gid - integer - id графика
    tid - integer - id  типа графика// не нужен, у нас и так график однозначно идентифицирует тип
    sinfo - varchar(6)  название колонки  //short_name
    svalue - varchar(6)  значение элемента суммированного учета //


CREATE TABLE s_data (
       aid integer primary key autoincrement,
       wid integer not null,
       gid integer not null,
       sinfo varchar (10) not null check(sinfo !=''),
       svalue varchar(10),
       constraint wso foreign key(wid) references workers(wid),
       constraint gso foreign key(gid) references graph(gid)
       )

Каждый отдельный график определяется 2 параметрами - ид графика(gid GRAPH_INFO) и 
ид типа графика (tid GTRAPH_TYPES). Даные этого графика хранятся в GRAPH_DATA для каждого 
работника и в S_DATA 

S_DATA - хранит данные для каждого работника в контексте 1 месяца. Годовые данные получаются 
непосредствнно в программе.

Так как суммированные учеты ведутся только программой, а не базой, то сами формулы в базе 
не хранятся, хранится только их результат. Хотя формулы привязаны к конкретному графику и их тоже
можно пихануть в БД

4. несмотря на использование БД, надо, чтобы была возможность сохранять графики и в отдельных фйлах
(он должен автомачически сохраняться в виде "месяц год tname.gr" в папке с соотв годом, или в 
папке data, если нет папки года (опционально))

5. надо как то добавлять к графику комментаиии, причем сразу к месяцу, а не к отдельному графику

6. При запуске программы можно открывать либо единичные графики, либо базу графиков. Если 
открывается база, то появляются новые элементы управления (можно прыгать по графикам след месяц, 
пред месяц, по типам графиков, добавление типов графиков, добавление сортировки персонала, ведение 
комментариев к графику), меняется поведение некоторых окон (список персонала, там факически другое 
окно появляется, на action надо смену окна сделать или в зависимости от того, через что работаем)


7. Использовать настройку типа (показывать вместо часов)
и в программе сделать флаг "всегда показывать часы под типами"

8. При изменении часов пересчитываются доп колонки. При закрытии графика они помещаются в БД 
автоматически. Если данная колонка участвует в суммированном учете, то она помещается в БД 
автоматически. Для каждого типа графика ведется свой суммированный учет.

9. Для удобства работы должны быть функции вида - "скопировать с предыдущего месяца", 
"скопировать с графика типа tname"


10. Типы графиков имеются 2 вида - основные, у них torder <> 0, и дополнительные, torder = 0.
    
11. Для нафигации по графикам БД на панели инструментов есть кнобки:
  - блок "месяц": кнопки следующий, предыдущий и с меню выбора месяца
  - кнобка с меню "тип графика" - в ней показываются все основные типы графиков и существующие 
  дополнительные для текущего интервала
  - Кнобка с меню год - показываются все существующие года и следующий
  

12. Создание нового графика может выполняться двумя способами.
  - через меню "Файл->Новый...": можно выбрать все параметры нового графика, в том числе загрузить 
  из файла
  - при помощи кнобок навигации из п.11 (блок месяц и тип графика) - предлагает создать новый 
  график на основе существующих параметров, если требуемый график не обнаружен, либо если 
  создавать не надо, показывает график с torder = 1
  При создании графика надо автоматически проставлять переходящие смены

13. Суммированный учет ведется на основании доп колонок (складываются их значения). Суммированный
  учет ведется для всех графиков, у которых torder <> 0. 

14. Для работ с графиками в БД должны быть пункты "Открыть базу графиков", "Создать базу графиков"
  При выборе этих пунктов прога переходит в режим работы с БД, на панели инструментов и в меню
  появляются дополнительные кнобки для работы с БД и удаляются кнобки для работы с файлами
  (из меню "Файл"). Для перехода в режим работы с файлами надо заново запустить программу.
  Также у нас в режиме работы с БД для некоторых действий применяются другие формы (список 
  работников)

15. Сохранение графика. Для каждой строки рботинка надо завести флаг "Modified", и устанавливать
  при редактировании. При сохранении графика сохраняем только измененные строки для каждого 
  работника, а также доп колонки для него. Причем должны сохраняться все доп колонки, участвующие
  в общих расчетах, а не только видимые.

16. Суммированный учет - форма результата должна немедленно отображать изменения в графике. Форму
  учета надо создать новую. Там не должно быть кнопки "извлечь" и "обновить", она сама тащит
  данные из графика для расчета. И данные хранит сразу все за год (только те, что запрашивались,
  если начало года, то конец не нужен скорее всего). Заводится годовой массив данных,
  но заполняется только то, что запрошено. Там все можно извлекать одним запросом,
  запихивать только надо по хитрому. Каждый элемент данных годового массива имеет флаг
  Modified, для меньшения кол-ва записей. Суммы "на лету" получаются из годового массива.
  Массив - для каждого воркера имеем на каждый _изменявшийся_ график, подлежащий расчету
  все колонки, которые должны вычисляться. Если создана новая вычисляемая колонка, то
  для ее заполнения надо хотя бы открыть все графики, для которых оно считается -
  при открытии графика система должна проверить, влруг надо что-то дорасчитывать, и
  сделать это.

  Система суммированного учета создается и запускается при старте программы,
  (пере)инициализирутся (год) при загрузке любого графика, при изменениях автоматически
  сохраняет свои данные. Для полного кайфа надо ей отслеживать события и изменения
  данных, и закрытия тек графика. (Для сохранения измененых данных). Список работников
  используется из текущего открытого графика, Но рассчеты ведутся для всех работников,
  которые открывались в этом году. (Оно автоматом будет получаться).

  При работе система использует тип графика, открытый в программе. Считает только то,
  что задал пользователь.
  Хранятся в базе все вычисляемые колонки, даже те, которые не показываются.


17. Создание графика. Есть кнобка "создать график". Та же, что и для файлов. Там вместо
  имени файла задается список работников для графика, остальное то же самое.
  Эта кнобка работает в случае, если у нас нет больше никаких графиков - создать можно только
  с помощью нее. Если же у нас есть какие то графики, то можно использовать данные из них.
  На выбор должно предлагаться существующие из того же месяца - тогда просто копируем все
  данные, а также какой либо предыдущий месяц - тогда копируем только список людей и переходящие
  смены (можно извратиться и попытаться получить д/н/48) - для этого используется кнобка
  "создать на основе"

18. Определение смен в след месяце. Заводим массив длиной 4, в каждом элементе 2 ячейки -
    кол-во дней и ночей. Лезем по предыдущему графику по каждому дню и с шагом 4 заполняем в массив
    то, что попадается. потм по кругу суммируем, день + след ночь. Где больше получается, то
    это - номер дня (1-4) в тек месяце, в котором у работника начинается дневная смена

19. Завести таблицу отсутствия - туда пихать отпуска, а также просьбы коллег на
  выделение дней.

20. Можно сделать режим просмотра диффов - выводится различие между несколькими видами 
	графиков по заданному человеку (можнео по нескольким доступным графикам).

21. Создание нового графика. Выбираем контролами на таскбаре тип и месяц графика. Затем нажимаем
	на кнобку "мастер создания". Если у нас уже есть график и нажать на мастер, то вылнзает окно с 
	предупреждением. Либо если есть график, кнобка мастера скрыта. 
	Вылнзает диалог создания нового графика. В нем можно задать 
	выхи и праздничные, а также график, на основе которого создается новый. может быть либо 
	какой то из этого месяца, из предыдущего месяца, из файла или вообще нет основы.
	Во всех случаях грузим основц и из нее извлекаем данные. Из этого месяца - тупо копируем
	из предыдушего - открываем, находим день работы в день и на основе его заполняем предыдущий, 
	а также переходящие смены, в 3 случае тоже копируем.
  График может создаваться новый, а может создаваться на основе открыттого пустого.
  в зависмости от этого могут быть активны не все контролы графика
  Форма создания графика для БД (новый/тек пустой) - определяется автоматически - если
  при переходе к какому то графику он отсутствует в БД. - gid = -1.
  - месяц и год создания  (+/-)
  - список выхов и праздничных (+/+)
  - список работников (+/+)
  - тип графика (+/+)
  - график, на основе которого создается (-/+). (может быть предыдущий месяц или текущий)
  После создания, если график, на основе которого создается - это предыдущий месяц,
  то происходит следующее
  - заполняются смены, переходящие с прошлого месяца
  - определяется порядок смен, и они тоже заполняются (п.18).
  - проверяется таблица отсутствий. Если есть какие то дни отпуска, то они помечаются
  соответствующим флагом.
  - если есть иные отсутствия, то под ними ставится "работа в день" с количеством часов 0.
  (надо для этого разработать какой-то новый флаг).


  Если же мы хотим запихнуть в базу график из текущего файла, то там будет другая форма,
  в которой надо указать:
  - тип графика
  - список людей
  Все остальное уже есть в источнике.
  Экспорт ведется по порядку сотрудников, для корректного экспорта необходимо, чтобы список
  людей в источнике совпадал с указанным списком людей.

22. Следать таблицу отсутствий - туда запихиваем инфу об отпусках, учебе, а также если чел 
	попросит какие-то дни дать, типа свадьба родственников и так далее.+++
  табордер на форме ввода норм сделать

23. Получение шаблона документа для импорта. Имеется настройка - шаблоны документов.
  Для каждого типа экспорта можно указать документ или пометить, чтобы использовался
  последний использованный шаблон. При выборе шаблона при экспорте открывается указ. шаблон
  и после этого в него передаются данные. Далее у шаблона задается имя в зависимоти от того
  какой экспорт (месяц год тип графика/имя графика).

25. Переделать графиковые таблицы

  GRAPH_INFO - инфа о месячном графике (она одна для всех графиков всех типов на указанный месяц)
    iid - integer - ид графика
    gyear - integer - год
    gmonth - integer - месяц
    def_sid - integer - порядок сортировки (и кто из людей находится в этом графике)
    wlist - integer - список выходных. по факту это 32 бит uint, в котором каждый бит=1,
            если это выходной или праздник
    udata - varchar(2000) - комментраии к графику

CREATE TABLE GRAPH_INFO(
   iid integer primary key autoincrement,
   gyear integer not null check (gyear>2000 and gyear<2100),
   gmonth integer not null check (gmonth>0 and gmonth<13),
   def_sid integer not null,
   wlist integer not null,
   udata varchar);
                        

  GRAPH - общая инфа по графику
    gid - integer ид графика
    iid - ссылка на общую инфу (GRAPH_INFO)
    sid - порядок сортировки графика (берется из graph_info.def_sid при создании графика)
    tid - тип графика или 0
    tname - string - если тип стоит 0, то здесь стоит имя графика (получается, такой график
      нужен только для каких то промежуточных действий, никаких сводных расчетов по нему не
      ведется)
    lm - DateTime - last modified

create table graph (
  gid integer primary key autoincrement,
  iid integer not null,
  sid integer not null,
  tid integer default 0,
  tname varchar(50),
  lm varchar not null,
  constraint gs
  foreign key (sid) references sort_info(sid),
  constraint gi
  foreign key (iid) references graph_info(iid)
  );


  GRAPH_DATA - данные работников (строки о работниках на каждый месяц)
    did  - integer - ид записи
    gid - integer - какой график
    wid - integer - ид человека
    gdata - varchar  - строка с данными человека (та же строка, что и в файловой версии).

create table graph_data (
  did int primary key autoincrement,
  gid integer not null,
  wid integer not null,
  gdata varchar,
  constraint gw
  foreign key (wid) references workers(wid),
  constraint gd
  foreign key (gid) references graph(gid)
  );

27. В меню вид добавить пункт "показывать часы под типами" - у нас для некоторых типов задана
    строка, которая показывается вместо часов. Данный пункт подавляет вывод этой строки, если
    у нас стоят часы в этом дне. В коде графика (кажется, когда из графика возвращается
    значение ячейки) или сетки прям стоит коммент об этом. +++

28. Ублюдочно реализовано подтверждние сохранения графика при выходе (неверно задан вопрос в
  окне подтверждения)

29. Если чего то нет в базе, какого - то ид, то при чтении его в прогу в соотв
  поле прописываем -1 !!!.

30. +++Проверка диффов с камасутрой более автоматизорованная. Копируем данные из камасутры в 
  спец окно, и далее выполняем стравнение с текущим открытым графиком. Сравниваем с помощью 
  питоноскрипта. Дифф выводим в отдельное окно. 
  Реализация - заводим в папке программы спец каталог со скриптами. В этот же каталог кидаем 
  временные файлы для сравнения, на них натравливаем скрипт, результат выводим в другое окно.

31. порядк реализации
  + преобразование файлового графика в БДшный
      + форма преобразования,
      + построение нового graph_info, если надо
  + сохранение преобразованного графика в БД
  + форма со списком графиков, там же и контролы перехода от графика к графику
  + чтение графика из БД
      + выбор на форме месяца и типа графика
      + загрузка из БД
  + создание нового графика БД (пустой, при необходимости добавление инфы для
    данных из соседних графиков)
  + создание графика бд нового типа (копирование)


мелочи
  + ВПР отдельно сохраняем (форма "свойства графика" - список людей и ВПР)
  + главная форма показывает, мы из базы или из файла (по заголовку видно)
  + кнопка сохранить сохраняет и в базу
  (короче, прицепить работу с базой к главной форме)
  - все формы переделать на 14 шрифт
  + работа с флагом modified и LM ?? вроде сохраняю, а при новой загрузке
  запрос все равно идет
  - при прыгании по графикам тоже запрос сохранения? (должно быть автоматом)

Когда работаем с базой, флаг FModified нужен только для того, чтобы понять, что
у нас есть измененые строки с людями. Сам он ни на что не влияет, толкьго вызывает
проход по строкам, чтобы выяснить, какие нужно сохранять
и обновить LM
+если мы в графике меняем ВПР и список людей, то мы их сразу же и сохраняем.

для корректной работы и с файлами, и с БД (настройка меню), можно сделать так
каждому менюитему, которой специфичен для какого-то режима, присваиваем значение
Tag: -1 - for files, -2 for Databases. other values - for any mode
та же самая фигня и с кнобками панели инструментов +++



sql для проверки базы
проверяет, чтобы у нас не двоились записи

select distinct gid, count(aid) a from s_data
group by wid, gid
having a>3
order by gid

показывает задвоенные записи

select * from s_data where gid = 37
order by wid, sinfo

валит задвоенные записи (надо удалять те, у которых ид меньше)
delete from s_data
where gid=37 and  aid > 1230


